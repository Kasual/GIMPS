This is glucas.info, produced by makeinfo version 6.5 from glucas.texi.

INFO-DIR-SECTION Local programs
START-INFO-DIR-ENTRY
* Glucas: (Glucas).              Glucas. A Mersenne number primality tester.
END-INFO-DIR-ENTRY


File: glucas.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

Glucas-YEAFFT
*************

This manual describes how to install, use, and some internals of the
library 'YEAFFT' and 'Glucas', a Mersenne number primality tester based
on it.

   This file documents the use and the internals of the 'YEAFFT' library
and the 'Glucas' application.

   Copyright 2000-2008 Guillermo Ballester Valor, Klaus Kastens

   This is edition 2.9.2 for release 2.9.2.  Last updated 22 January
2016

   The 'YEAFFT' code is licensed under GPL <GPL license>.  The specific
Lucas-Lehmer test contains many ideas from several authors (*Note
Copying::.)

* Menu:

* Copying::                    YEAFFT Copying Conditions (GPL).
* Glucas and YEAFFT::          How is related this software.
* Introduction to YEAFFT::     Brief introduction to YEAFFT.
* Introduction to Glucas::     Brief introduction to Glucas.
* Installing Glucas::          How to configure and compile Glucas.
* Glucas basics::              What every Glucas user should know.
* Invoking Glucas::            How to call Glucas.
* Glucas internals::           Internal details of Glucas.
* Contributors::               Who has contributed to this code?
* Save file format::           Interchangeable Mersenne number format
* Concept Index::              Concept and keyword index.
* GPL license::                GPL License document


File: glucas.info,  Node: Copying,  Next: Glucas and YEAFFT,  Prev: Top,  Up: Top

Glucas-YEAFFT Copying Conditions
********************************

'YEAFFT' ('YE't 'A'nother 'F'ast 'F'ourier 'T'ransform) is licensed
under GPL (*Note GPL license::.)  'Glucas' is a part of code using
'YEAFFT', which makes primality tests of Mersenne numbers.  This code is
related to user interface and Lucas-Lehmer specific code.  It can be
considered as free code, because it includes code and ideas from many
other authors and we honestly are not the owners.  Once said that,
almost all this code is from the 'YEAFFT' authors (*Note
Contributors::.)

   What follows is referred to 'YEAFFT' library.  To see what part of
code belongs to this license see the source code.  At the top of every
file in the package you will see the license GPL (if any).  (*Note GPL
license::.)


File: glucas.info,  Node: Glucas and YEAFFT,  Next: Introduction to YEAFFT,  Prev: Copying,  Up: Top

How Glucas and YEAFFT are related
*********************************

'YEAFFT' ('YE't 'A'nother 'F'ast 'F'ourier 'T'ransform) is a library
designed to perform integer multiplication of very big numbers using
"FFT" (Fast Fourier Transforms).  This library is written based on this
paper (http://www.perfsci.com/free/techpapers/confgt.pdf).  It is mostly
a C-coded library, but it has lots of assembler macros for GNU/gcc
assembler call style for x86 processor family.

   'Glucas' is an application using 'YEAFFT' in a very optimized way.
It is the first program using the 'YEAFFT' library, and because it is
written by the same authors as 'YEAFFT', it squeezes this library in a
very efficient way.  The main goal of 'Glucas' is to analyze Mersenne
numbers checking whether they are prime numbers.

   There are differences between the copying licenses of both codes.
'YEAFFT' is a GPL licensed library (*Note GPL license::.), while the
Glucas specific code is free.  (*Note Copying::.)


File: glucas.info,  Node: Introduction to YEAFFT,  Next: Introduction to Glucas,  Prev: Glucas and YEAFFT,  Up: Top

What is YEAFFT
**************

'YEAFFT' ('YE't 'A'nother 'F'ast 'F'ourier 'T'ransform) performs integer
multiplications of very big numbers using 'FFT' (Fast Fourier
Transforms).  This library is written based on this paper
(http://www.perfsci.com/free/techpapers/confgt.pdf).  It is mostly a
C-coded library, but it has lots of assembler macros for GNU/gcc
assembler call style for x86 processor family.  It also has some memory
prefetch hints for other compilers and processors.

   'YEAFFT' is not a general purpose FFT package.  It essentially makes
convolutions of two real arrays.  It is a floating point based FFT, not
an all integer transform.  Because of that, there are some controls to
make sure the results are correct.  To read more about 'YEAFFT': (*Note
Glucas internals::.)


File: glucas.info,  Node: Introduction to Glucas,  Next: Installing Glucas,  Prev: Introduction to YEAFFT,  Up: Top

Introduction to Glucas
**********************

'Glucas' is the first code intensively using 'YEAFFT'.  Up to version
2.x, it basically does Lucas-Lehmer tests of Mersenne numbers.  (*Note
Mersenne number::.)(*Note Lucas-Lehmer test::.)

   'Glucas' is designed to test the primality of Mersenne numbers using
idle cycles of your system at the lowest priority (nice).  So you have a
chance to discover the biggest known prime number.

   There is a big project in the Internet: 'GIMPS' (Great Internet
Mersenne Prime Search (http://www.mersenne.org/)).  As the name says, it
tries to find Mersenne prime numbers.

   "PrimeNet" is a server service hosted by entropia.com
(http://www.entropia.com).  It is a great server for 'prime95' family
clients, which automatically contacts PrimeNet to reserve Mersenne
numbers for testing, reporting of results and other account management.
These clients are exclusively for x86 family processors because they are
assembler coded applications.  Indeed, they are faster than everything
else running on these systems.

   For all other processors out there, an alternative client is
'Glucas'.  At the moment, there is no automated server to reserve
numbers or report results, but we think there will be one soon.

   In a few words, the user has to reserve a number from 'GIMPS' or
PrimeNet pool.  Then 'Glucas' makes the test, saying us whether the
chosen number is a prime and finally we have to send this result to the
server.  To reserve Mersenne numbers for testing or reporting results
use the PrimeNet Manual Testing Forms
(http://www.mersenne.org/ips/manualtests.html) or alternatively choose
an exponent from GIMPS Reserve Exponents page
(http://www.mersenne.org/range2.htm) and report the results per e-mail.

   But before doing anything, I would recommend reading the basics of
'Glucas'.(*Note Glucas basics::.)


File: glucas.info,  Node: Installing Glucas,  Next: Glucas basics,  Prev: Introduction to Glucas,  Up: Top

Download, configure, make and installing Glucas
***********************************************

'Glucas' source and binaries are available from the download area at
sourceforge.net
(http://sourceforge.net/project/showfiles.php?group_id=24518).  You also
can download older binaries here
(http://glucas.sourceforge.net/oldbin.html).

   You can either choose to download a prebuilt binary suitable for your
OS/system or build your own binary from the source code.

Installing a prebuilt binary
============================

This is the easiest solution, you only have to download, unzip, make a
short selftest and move the binary to your preferred directory.

   Once you've downloaded the zipped binary file
'Glucas-version.CPU.OS.tar.gz' you need to uncompress using tar and
gzip.  On UNIX like systems

     tar zxf Glucas-version.CPU.OS.tar.gz

   or in two seperate steps

     gzip -d Glucas-version.CPU.OS.tar.gz
     tar xf Glucas-version.CPU.OS.tar

   This will create a directory 'Glucas-version.CPU.OS', containing the
executable 'Glucas' and some short documentation.  It is recommended to
run a short selftest (*Note Selftest::.).

     cd Glucas-version.CPU.OS
     ./Glucas -s [small | big | huge | enormous | primenet | all]

   If successful you could move 'Glucas' to one of your systems binary
directories (i.e.  '/usr/local/bin/' or '~/bin/').

     mv Glucas  /your_Glucas_directory_path

   Make sure this directory is in your environments PATH, otherwise you
always have to execute it with the PATH preceded.  (i.e.
'/usr/local/bin/Glucas').

Building your own binary.
=========================

This section is for users who want (or need) to build their own binary
from the source code.  If you're not skilled in these things, you might
find it somewhat difficult.  At the moment, it is not easy to build and
install for non-UNIX/Linux platforms.  It requires editing some files.

   Anyway, the usual './configure' and 'make' procedure works for most
Processors/OS. This should build a binary tuned for your system.  For
systems not detected by the configure script, there will be a warning
displayed, but in most cases it should nevertheless be possible to use
'make' and build a binary (Though not tuned for your system).

* Menu:

* Configure Make and Install::    How to Configure Make and Install Glucas
* Alternative builds::            How to make Glucas with your preferences
* Glucas compiler options::       Options to build Glucas


File: glucas.info,  Node: Glucas basics,  Next: Invoking Glucas,  Prev: Installing Glucas,  Up: Top

What every Glucas user should know
**********************************

'Glucas' is a free program to test the primality of Mersenne numbers.
(*Note Mersenne number::.)  Its results say us whether a Mersenne number
is a prime number.  It uses a special recurrence sequence to test the
primality.  (*Note Lucas-Lehmer test::.)

   It is supposed you previously have read the introduction.  (*Note
Introduction to Glucas::.)

   'Glucas' source and binaries are available from the download area at
sourceforge.net
(http://sourceforge.net/project/showfiles.php?group_id=24518).

   You can either choose to download a prebuilt binary suitable for your
OS/system or build your own binary from the source code.

* Menu:

* Selftest::                 Glucas selftest.
* Glucas_test::              Even more complete selftest.
* Usage::                    How to invoke Glucas
* Configure files::          How we can set some options.
* Output::                   What means the output files.


File: glucas.info,  Node: Invoking Glucas,  Next: Glucas internals,  Prev: Glucas basics,  Up: Top

How to invoke Glucas.
*********************

Once 'Glucas' is installed correctly, you can invoke it like any other
executable in your system.  There are some command line options you
should know about.  (*Note Usage::.)

   Some other features can be configured by editing an 'ini' file.
(*Note Configure files::.)


File: glucas.info,  Node: Glucas internals,  Next: Contributors,  Prev: Invoking Glucas,  Up: Top

To know more about 'Glucas', it is necessary to be familiar with some
concepts

* Menu:

* Mersenne number::                  What is a Mersenne Number
* Lucas-Lehmer test::                What a Lucas-Lehmer test does

   As you can read about Lucas-Lehmer test (*Note Lucas-Lehmer test::.),
basically this test is a series of modular squares and subtractions.  To
have any chance to understand what follows you have to be familiar with
modular arithmetic and Fast Fourier Transforms.

   'Glucas' is an application to deal with Mersenne Numbers while
'YEAFFT' is a collection of routines designed to perform general integer
convolutions.

Glucas general structure
************************

Here we only want to give a general view of 'Glucas''s structure.
Better than being verbose about algorithms, techniques and tricks used,
it is better to directly look at the source.

   The main routine of 'Glucas' is located in the file 'glucas.c'.  It
is the top level routine.  Here the argument parsing control, the main
Lucas-Lehmer test control, the calls to input/output, initializing,...
can be found.  The main header for 'YEAFFT' is 'yeafft.h' and for
'Glucas' is 'glucas.h'

   The Input/output code is mainly located in the file 'gio.c'.  The
initial work for 'YEAFFT' is done in the file 'yeainit.c'.  'lucasini.c'
initializes special arrays needed for Lucas-Lehmer test and DWT.

   The signal management is done in the file 'gestup.c'.

   The builtin selftest code is located in 'selftest.c'.

   The POSIX threads are directed from 'gthreads.c' file.  'OpenMP',
'_SunMP', or POSIX thread directives or special routines can be found in
'gthreads.h', 'glucas.c', 'ynorm_*.c' files, 'lucasini.c', 'yealucas.c'
and 'yeafft1.c'.

   When rounding the float elements, a fast round trick is used.  The
round trick constants can be found in 'tricky.c'

   Prefetch data macros are located in the file 'prefetch.h'.  You can
also find tons of assembler macros for x86 architecture in the
'*yx86*.h' header files.

   The passes in a L-L test and the calls to 'YEAFFT' routines are in
'yeafft.c', 'yeafft1.c' and 'yealucas'.

   The general passes in a Lucas-Lehmer iteration, after reading from a
save file ('ginput()' and 'read_check_point()' in 'gio.c' file) are

  1. Transform the data: The data is transformed from Mersenne
     Interchangeable Residue Format.  (*Note Save file format::.)  to an
     array of double floats.  This task is performed by the
     read_standar() routine in 'gstd.c' file.  The data is cut into
     small chunks of about 19 or 20 bits and balanced.

  2. Multiply the data by DWT factors: Here the data is prepared to be
     used by 'YEAFFT'.  It is needed to multiply by weighed factors.
     This is done by the normalize_first() routine in the file
     'ynorm.c'.

  3. First initial forward FFT pass: Already suited for FFT, a first
     forward FFT pass is performed with the aid of routines 'radix_*.c'
     from the 'YEAFFT' library.  Once this step is done, the data is
     ready to enter the normal Lucas-Lehmer loop iteration cycle.

  4. Optimized Lucas-Lehmer iteration: Starting from data after step 3,
     a normal optimized Lucas-Lehmer iteration includes the following
     steps.  Note that a normal cycle begins in F. At the end of E is
     where it can jump to multi thread execution or abandon it.

       A. Forward DIF FFT pass 1: It includes all forward FFT radices
          reduction steps while the needed data cannot be encapsuled
          into independent data arrays of 'Y_MEM_THRESHOLD' complex
          size.  (routines in files 'radix_4.c', 'radix_8.c',
          'radix_16.c' and 'radix_32.c'.

       B. Forward DIF FFT pass 2: The remaining forward steps except for
          the last one.  Made by the same routines than prior item.

       C. Last forward DIF FFT step, dyadic square and first backward
          DIT FFT step.  To optimize memory accesses: All these three
          processes are made by the same routines (see 'difdit_4.c',
          'difdit_8.c', 'difdit_16.c' and 'dyadic_32.c').

       D. Backward DIT FFT pass 2: Backward DIT FFT steps while moving
          between 'Y_MEM_THRESHOLD' limits.  Items B, C and D are made
          successively in a loop of blocks of independent data after A.
          Once finished, all blocks of memory are passed to the next
          item.

       E. Backward DIT FFT pass 1: Backward DIT FFT steps.  The last
          backward step is excluded.  After this pass the type of the
          next iteration is analyzed.  If the next L-L iteration is
          normal, then it continues in the next item and jumps to
          multithreaded (if required), if not jump to single thread and
          go to item 5.

       F. Last backward DIT FFT step, mul by inverse DWT factors,
          normalize data, subtract two, mul by DWT factors, and first
          forward DIF FFT step: All these tasks are performed at once by
          the 'ynorm_*.c' files.  Once this is done, go again to A to
          the next L-L iteration.

     When an interrupt signal is received, or it is required to write a
     save file, or the Lucas-Lehmer is finished, then F is substituted
     by

  5. Last backward DIT FFT: It is completed the inverse FFT. (routines
     in 'radix_*.c' files).

  6. Subtract two, mul by inverse DWT factors, normalize: This is done
     by the routine last_normalize() in the file 'y.norm.c'.  Here can
     be checked if the residue is zero after a finished L-L test or
     extract the first 64 bits in the residue if it is required.
     (routines 'iszero()' and 'res64()' in file 'gio.c').

     If it have to write a save file then next two items are
  7. Convert float data to integer format: ('gstd.c', 'compat.c' files)

  8. Write a save file: ('gio.c')

References and further reading.
*******************************

The best place to begin reading about Mersenne Primes, GIMPS and related
stuff is Mersenne.org (http://www.mersenne.org/prime.htm)

   There is a very nice site World of Mathematics
(http://mathworld.wolfram.com), where you can consult almost every
mathematical concept.  I really recommend to consult this site.  Is by
far deep and better about mathematics than anything we can write here.

   A good index about primes is Chris Caldwell's The Prime Pages
(http://www.utm.edu/research/primes/).  You can see a lot of theorems
and proofs related to primality tests.

   To know more about R. Crandall and B. Fagin 'Discrete Weighted
Transform (DWT)' see the original paper: "Discrete weighted transforms
and large-integer arithmetic", Math Comp, 62 (1994),305-324.

   To understand the special algorithm 'YEAFFT' uses, it is necessary to
read the paper "Integer convolution via split-radix fast Galois
transform", by R. Crandall.  You can download a free postscript copy
from perfsci.com (http://www.perfsci.com/free/techpapers/confgt.ps).
Note that 'YEAFFT' uses floating point trigonometric FFT, not Fast
Galois Transform.  Anyway the algorithm is easy to use in trig.  FFT.


File: glucas.info,  Node: Contributors,  Next: Save file format,  Prev: Glucas internals,  Up: Top

Who contributed to this code
****************************

Guillermo Ballester Valor has written most of the code, both 'YEAFFT'
and 'Glucas'.  First drafts are from April 2000.

   Klaus Kastens has joined the project from release 2.8b, July-2001.
He has made a great work.

   There are other people who have contributed to make this code
possible in several ways:

   Glucas specific code is an adaptation of Richard Crandall 'lucdwt.c',
Sweeney 'MacLucasUNIX.c' and Will Edgington 'mers' package.

   Ernst W. Mayer suggested to write a specific C-coded FFT package
based on Richard Crandall paper scheme.  He kindly gave Guillermo a
telnet account on his machines, and Glucas-YEAFFT also has some ideas
borrowed from his excellent f90 code 'Mlucas'.

   George Woltman, the heart of the Great Internet Mersenne Prime Search
He has written 'prime95', the fastest code for Pentium ever seen.  The
speed of this code has been the wanted milestone in the design of
'YEAFFT'.

   The alignment of doubles on stack, using 'GNU/GCC' compiler on intel
x86 has been a problem.  It is almost the most important thing which
affect to performance.  Thanks to 'FFTW' developer team to point at the
solution.  Actually, 'YEAFFT' uses its tricks to align the stack.

   B.J. Beesley has made a great QA work.  He also told us the way how
to include assembler prefetch hints in Compaq-c compiler for alphas, and
reported several smaller bugs.

   Tom Cage has made an excellent work as a beta tester and also ported
'Glucas' to Mac OS.

   Thomas Perrier also helped tuning and building binaries for Mac OS X.

   Gregory Matus, who reported memory problems under OpenBSD.


File: glucas.info,  Node: Mersenne number,  Next: Lucas-Lehmer test,  Up: Glucas internals

What is a Mersenne number
*************************

A Mersenne number is an integer number in the the form

     M(p) = 2^p - 1

   The number 'p' is the "Mersenne exponent".  Its binary representation
is just a chain of 'p' ones.  This kind of numbers have a lot of nice
properties which make them easier than a general integer.  You can read
a lot more about Mersenne numbers at Chris Caldwell's Mersenne Primes
(http://www.utm.edu/research/primes/mersenne/) pages.

   The special form of Mersenne numbers gives us three big advantages:

   * There is a fast test (*Note Lucas-Lehmer test::.)  If it succeeds
     we are sure the analyzed number is a prime number.  If it fails
     then we are sure the number is not prime.

   * The modular reduction we need can be made in a easy way.  (*Note
     Glucas internals::.)

   * The algorithm used to multiply the very big numbers we usually need
     (about some million bits) uses a special form of Fast Fourier
     Transform, the "Discrete Weighted Transform" ('DWT') described by
     R. Crandall and Fagin (1994).  With 'DWT', the speed is almost
     double than traditional 'FFT' schemes.

Mersenne primes
===============

It is a well known result that 'M(p)' is prime only if 'p' is prime.
Unfortunately, if 'p' is prime this does not mean 'M(p)' is prime.
Actually, up to 22 January 2016 there are only 47 known Mersenne primes.

   The values of mersenne exponents 'p' for 'M(p)' prime are:

     2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
     3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
     110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
     6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
     37156667, 42643801, 43112609


File: glucas.info,  Node: Lucas-Lehmer test,  Prev: Mersenne number,  Up: Glucas internals

What is the Lucas-Lehmer test.
******************************

The Lucas-Lehmer test is a test of primality for Mersenne numbers (*Note
Mersenne number::.).  This test was discovered by Lucas in 1870, and
written in the definitive form by Lehmer in 1930.  You can see more
details about Lucas sequences here
(http://mathworld.wolfram.com/LucasSequence.html) and about Lucas-Lehmer
test in this page (http://mathworld.wolfram.com/Lucas-LehmerTest.html).

   In short, the nicest thing of the Lucas-Lehmer test is its simplicity
and power.  The recurrence sequence is as follows:

     L(0) = 4
     L(i+1) = ((L(i)*L(i) - 2) Mod M(p)
   here
     A mod B
   is the remainder of the integer division A/B.

   And it is proven that M(p) is prime if and only if L(p-2) = 0

   Thus, to see whether a Mersenne number M(p) is prime is very easy.

   With the '-D' and '-d' command line options, it uses an initial shift
displacement of L(0) so the subsequent residues are related with the
unshifted original sequence by shifting (rotating) the proper amount of
bits.  This allows 'Glucas' to double-check L-L tests already tested
with the same program.  DWT scrambles the data in such a way that two
different initial shifted sequences can be considered as independent.


File: glucas.info,  Node: Selftest,  Next: Glucas_test,  Up: Glucas basics

Glucas builtin selftest.
************************

If the 'Glucas' binary has been compiled without problems or you've
downloaded a precompiled binary, it is recommended to run a short
builtin selftest.  This will show if 'Glucas' runs properly and also
displays some basic timings.

   There are 31 basic different selftests, every one belonging to a FFT
runlength.  There are also two kinds of selftests.  A selftest is a run
of few Lucas-Lehmer iterations.  If it used the '-s option' there will
run only first 100 iterations per selftest.  When using the '-S option'
there will be 1000 iterations per selftest.

   We can select the sample of test to run.

   To run a selftest you have to invoke Glucas with the '-s option' or
'-S option'.  'option' is one of the following

'n'
     Here 'n' is a number from 1 to 31.  It simply selects which
     selftest to run.

'runlength'
     'runlength' selects the FFT runlength test to run directly
     (expressed in 2^10 = K units).  The available values are 128, 144,
     160, 192, 224, 256, 288, 320, 384, 448, 512, 576, 640, 768, 896,
     1024, 1152, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3584, 4096,
     4608, 5120, 6144, 7168, 8192.

'primenet'
     'primenet' will run selftest 6 to 21, i.e, from 256 to 2048 K FFT
     runlength.  This roughly covers the complete range of exponents
     currently tested by PrimeNet (5M - 35M), including ten million
     digit prime candidates.

'small'
     'small' will run selftest 1 to 11, from 128 to 512 K FFT runlength.

'big'
     'big' will run selftest 5 to 21, i.e, from 256 to 2048 K FFT
     runlength.

'big'
     'big' will run selftest 11 to 21, i.e, from 512 to 2048 K FFT
     runlength.

'huge'
     'huge' will run selftest 21 to 26, i.e, from 2048 to 4096 K FFT
     runlength.

'enormous'
     'enormous' will run selftest 26 to 31, i.e, from 4096 to 8192 K FFT
     runlength.  *to run this test you will need a system with plenty of
     memory.  Selftest 31 typically uses about 128 M of memory*.

'all'
     'all' will run all 31 selftests.  *to run this test you will need a
     system with plenty of memory.  Selftest 31 typically uses about 128
     M of memory*.

   As example

     ./Glucas -s small

   will run the selftests from 128 to 512 K FFT runlength.

   The amount of memory needed can be big enough to get you into
problems.  So *be careful with the memory requirements*.  'Glucas' uses
about a byte per bit, ie, to test M(66060289) it will need a minimum of
64M bytes, but if the errors in initial phase are bigger than a
threshold the amount of memory can increase up to 80 Mbytes.  Please,
don't try to run big selftests unless you have enough memory.

   For timing purposes it is important to note that 'Glucas' is very
sensitive to cache misses.  If another 'memory hungry' program is
running at the same priority 'Glucas' performance will drop because the
available L2 cache memory will be reduced.  So, if you want to compare
the timings with other programs/platforms, be sure that programs like
'Mlucas', 'mprime' or 'MacLucasUNIX' are sleeping during the test.

   During selftests 'Glucas' will run at normal priority, automatically
enabling the 'no nice' flag.  So be careful and don't select runs too
big.  A short result of each selftest will be printed to 'stdout'.  In
addition more detailed results about errors and timings will be printed
to the two files 'selftest.res' and 'selftest.out'.  This information
can be used to tune the 'Glucas' binary.

   Because at run time 'Glucas' makes an initial accuracy adjustment
phase, the FFTs actually used can be different than expected.  This
depends on the roundoff errors obtained in the first iterations.  The
only important thing here is to pass the test giving the correct 64 bits
residue.


File: glucas.info,  Node: Glucas_test,  Next: Usage,  Prev: Selftest,  Up: Glucas basics

Even more complete Glucas builtin selftest.
*******************************************

A critical part of the code is the one who writes and read de "save
files".  In this files 'Glucas' stores complete information about the
work done so far, and it can restart the work in the point where it
left.  'Glucas_test' will check whether it can do safe.

   'Glucas_test' is a small Bash script for Unix like OS calling Glucas
selftest (*Note Selftest::.).  The usage is


     Glucas_test arg


   Where arg is any of the arguments described in selftest section
(*Note Selftest::.).  As example if you want to make a test for 1024 FFT
runlenght (selftest 16) you can do


     Glucas_test 16


   If you want to check the ranges used in primenet (selftest 5 to 21)
you can try


     Glucas_test primenet



File: glucas.info,  Node: Usage,  Next: Configure files,  Prev: Glucas_test,  Up: Glucas basics

Glucas Configure files.
***********************

At the moment, Glucas only does Lucas-Lehmer tests.  Glucas manages the
work to do in a "queue file" we can select.  In addition to some
features selectable on the command line, there is an "ini file" we can
also use to configure more important aspects of Glucas and a "results
file" where Glucas writes the most important results (not the
verbose-output).  (*Note Configure files::.)

   The usage of 'Glucas':

     Glucas [-c][-d][-o][-n][-K kill_iters][-N nice_adjustement][-f][-v]
            [-i inifile][-s option][-r resultfile][-q queuefile][-z]
            [-W Work_directory][file1][file2]

   The optional [ ] items are:

'-c'
     *Enable universal compatible save file format*.  This is the
     default.  To enable old sytle format use *-o* option.

'-d'
     *Use initial random shift*.  With this option, 'Glucas' performs an
     initial random shift.  The first Lucas-Lehmer iteration is (*Note
     Lucas-Lehmer test::.)  L(0)=4<<(initial_random_shift), with the
     default set to L(0)=4.  With this initial random shift algorithm,
     two different Lucas-Lehmer tests made with same program on the same
     platform (but different random shifts) can be considered as
     independent.  This option is used when doing double-checks.

'-h'
     *Display help lines*.  This option displays some help lines with
     the most common command line options.

'-K kill_iters'
     *Auto Kill*.  This option auto kill Glucas every kill_iters
     iterations.  The only propose of this option is to check the
     routines and the medium to read and write save files.  Calling
     'Glucas' sucesively with this option we can check the routines that
     read and write save files.  The script for Unix like OS *Note
     Glucas_test::.  does that for us.

'-o'
     *Write the save files in old style format*.  By default, 'Glucas'
     writes the save files using the compact integer format for
     residues.  When this flag is enabled, the save files are compatible
     with 'MERS rw()' format.  The save files in this form are three
     times bigger than the default format.  Most important, the default
     uses the compatible Mersenne residue format, making the save files
     compatible among most platforms and processors out there.  So, if
     you don't need it, don't use the '-o' flag.

'-n'
     *No nice flag*.  When selected, 'Glucas' will run at normal user
     priority.  This can slowdown other tasks.  Don't use it unless you
     are going to do a short test, especially if you are not the owner
     of the system.  If you want a customized nice priority use '-N'
     option.

'-N nice_adjustement'
     *Nice adjustment option*.  When selected, 'Glucas' will run at
     priority 'nice_adjustement'.  Higher value means lower priority.
     '-n' flag is equivalent to '-N 0'.  If the OS allows you to set
     negative values, Glucas will run at high priority.  Don't use it
     unless you are going to do a short test, especially if you are not
     the owner of the system.

'-T number_of_threads'
     *Select number of threads*.  When compiled with '--enable-pthread'
     in configure step, 'Glucas' will use 'number_of_threads' threads.
     You even can use '-T 1' but it is recommended to use the
     non-threaded compiled version if you one to run a single-threaded
     version, otherwise you will lost performance.

'-z'
     *Force bigger FFT runlength*.  The FFT run length is bigger than
     necessary so the roundoff error are very small.  Useful to discard
     roundoff errors in verification tasks, but it will run about 25%
     slower than with the default FFT runlength.

'-v'
     *Output Glucas version*.  This option prints the version of Glucas
     to stdout and exit.

'-f'
     *Force this work to be done first*.  When 'Glucas' is called with a
     worktodo file as argument on the commandline, by default this files
     work is appended at the end of the 'queue file'.  Using this flag,
     the the work is prepended at the the beginning of the 'queue file'
     instead and will be done first.

'-r resultfile'
     *The file where summarized result will be stored is 'resultfile'*.
     The default file is 'result'.

'-s options'
     *selftest*.  Glucas will perform small selftests for selected
     exponents / FFTs .  (100 iterations per selected FFT
     runlength)(*Note Selftest::.)

'-S options'
     *selftest*.  Glucas will perform selftests for selected exponents /
     FFTs .  (1000 iterations per selected FFT runlength)(*Note
     Selftest::.)

'-i inifile'
     *The inifile is 'inifile'*.  Here you can set the 'ini' file.  The
     default file is 'glucas.ini'.  An existing 'ini' file in the
     working directory is optional.

'-q queuefile'
     *The queue file is 'queuefile'*.  Here you can set the 'queue'
     file.  If you don't select any, the default queue file will be
     'glucas.que'.  *NOTE*: It is important to note that the queue files
     are for internal use of Glucas.  Some users have tried to use files
     from "PrimeNet" as queue files and reported getting errors.  To
     *import* files in PrimeNet format, simply add their name as last
     argument on the commandline (see below).  Anyway the format of
     queue files is easy.  A plain ascii line per exponent with four
     numbers.  First is the exponent, second is the task (0 = First L-L,
     1 = Double Check) and then other two parameters (at the moment 0).

'-D initial_shift'
     *Force initial shift*.  This option is similar to the '-d' option.
     Instead of using a random initial shift, this uses the commandline
     argument 'initial_shift'.  Used in some QA work.

'-W work_directory'
     *The working directory*.  Except binary, 'Glucas' will read
     from/write to this 'work_directory'.  Don't use this option with
     selftest flag before.  Write first the '-W' option and then '-s'
     option instead.

'file1 file2 ...'
     *Do the valid work in files: file1,file2 ...*  First, these
     arguments will be tried as file names.  If existing, the valid work
     will be extracted and queued.  Otherwise the arguments will be
     considered as an exponents to test.  If there is no valid work, the
     queuefile remains unaltered.

     'Glucas' is prepared to import the 'worktodo' files from "PrimeNet"
     manual test forms.  Paste the work obtained from PrimeNet in a file
     and restart 'Glucas':

          Glucas [options] file

     the work will be appended to the 'queue' file.  'Warning': A queue
     file can only have up to 128 exponents to test.  Do not make larger
     queue files.

   Obviously, 'Glucas' will stop when there is no other job in the
'queue' file.  When a job is interrupted, Glucas will store the work
already done to save files.  When restarting, Glucas will continue at
the point it left the work for a given exponent.  Remember 'Glucas' will
continue the task of the 'queue' file we enter (or the default
'glucas.que').


File: glucas.info,  Node: Configure files,  Next: Output,  Prev: Usage,  Up: Glucas basics

Configuring and preferences.
****************************

In addition to the command line options we can use when invoking
'Glucas', there are some other options we can set in an 'ini' file.  By
default this file's name is 'glucas.ini'.  If we want to use another
than the default file we have to enter it as command line argument
(*Note Usage::.).  The options must be in the form 'Option=value', one
per line.  No blank space is permitted.  These are the supported
Options:

'Alternative_output_flag=[0/1/2]'
     If 'Verbose_Flag' is active, then the output is written to a file
     pointed by 'File_output' when 'Alternative_Output_Flag' is set to
     '1'.  If zero, the output is 'stdout'.  If two, the output is send
     to both 'File_output' and 'stdout'.


'Check_iteration=value'
     Set the number of iterations to do if 'Only_check_flag' is enabled.
     It is useful in test/timings tasks.


'File_output=my_output_file'
     When this line is included and 'Verbose_flag' is active, then the
     verbose output is written to this file.  If both 'Verbose_flag' and
     'Alternative_output_flag' are active and no output file is given,
     the default is 'glucas.out' file.  Here only the name of the file
     is entered.  The directory path must be added with '-W' option on
     the command line whenever this file is not in the current working
     directory.


'Iteration_output=value'
     Set the rate of information when 'Verbose_flag' is enabled.
     'Iteration_output=n' outputs information every 'n' iterations.  The
     default value is 20000.


'Last_error_flag=[0/1]'
     If enabled ('=1') and Verbose_flag is enabled, then the output
     includes the last computed roundoff error.  The default is '0'.


'Only_check_flag=[0/1]'
     If enabled ('=1'), *Glucas* performs only a partial Lucas-Lehmer
     test.  The number of iterations to do is controlled by
     'Check_iteration'.  This option is useful for debugging and timing
     purposes.  The default is '0'.


'QA_interim_file=n'
     To make QA tasks easy, 'Glucas' will save an interim file every 'n'
     iterations with this line.  The format of the filename is
     'sMMMMM_NNNN', where 'MMMMM' is the exponent and 'NNNN' the
     iteration saved.  As example 's9791209_00100000' would be the
     interim file for M(9791209) with the residue at iteration 100000.
     On the verbose output file, and on the 'results' file, an output
     with the less significant bits of residue "RES64" will be printed.
     If you are a lot lucky and find a new prime, then the file
     'sMMMMM_last' will remain in your working directory, and it will be
     used as a first check to see whether the results are likely correct
     and discard software/hardware errors.


'Roundoff_check=[0/1]'
     When it is active ('=1'), then the roundoff error check is
     activated for every iteration.  When it is set to zero, then
     roundoff checking is completely disabled.  *Be careful with this
     option, a critical roundoff error might not be detected*.  Without
     this line Glucas will make a roundoff check for every iteration
     during the first 131032 iterations and every 64 iterations after
     that.  If Glucas was compiled with the 'Y_SECURE' flag, the
     roundoff check will be made for every iteration regardless of this
     setting.


'Save_iterations=n'
     By default, 'Glucas' writes a save file every 5000 iterations.  The
     purpose of this file is to preserve the work already done.  This
     file will be used as starting point when Glucas restarts after
     terminating or during the initial accuracy adjustment phase.  If
     the verbose_flag is enabled, then the less significant bits of the
     residue (RES64) will be printed.


'Time_flag=[0/1]'
     If enabled, 'Glucas' prints the real time wasted from last output.
     If the system has the user time available it also prints it.


   *NOTE:* From version 2.7, 'Glucas' writes a random 32-bit integer as
Identifier machine whether the 'ini' file still has not one.  The line
appended is in the form

     Computer_ID=n

   and you should not modify this line.  The 'g' file also has this
identifier of the machine which made the work.  If the 'Computer_ID'
from 'ini' and 'g' files don't match, 'Glucas' will take this as a
change in the Hardware/Software context and will enable the roundoff
error checking as in the first iterations of a Lucas-Lehmer test.  This
feature was added because the default format for save and interim files
uses the interchangeable format, and therefore can be used by most
platforms.  It is thought as a method to detect if the 'save' file used
is from another machine.

Examples
========

Here are two examples of 'ini' files.

   The first example only runs a partial Lucas-Lehmer test.

     Verbose_flag=1
     Alternative_output_flag=1
     File_output=my_file
     Last_error_flag=1
     Time_flag=1
     Iteration_output=100
     Only_check_flag=1
     Check_iteration=1000

   With this 'ini' file.  'Glucas' will write information to the file
'my_file' every 100 iterations.  The Lucas-Lehmer test will be
terminated at iteration 1000.  The output will include timings and
roundoff errors.  By default, the 'queue' file will be 'glucas.que',
unless we use another filename on the command line.

   The second example is for a long and complete QA Lucas-Lehmer test.


     Save_iterations=5000
     QA_save_file=1000000
     Verbose_flag=1
     Alternative_output_flag=1
     File_output=my_file
     Last_error_flag=1
     Time_flag=1
     Iteration_output=10000
     Only_check_flag=0


   Here 'Glucas' will write verbose information to the file 'my_file'
every 10000 iterations.  It will write a save file every 5000 iterations
and the residue RES64 will be printed.  Every 1000000 iterations an
interim file will be saved, and the RES64 will be printed in both
'my_file' and 'results' file.


File: glucas.info,  Node: Output,  Next: Configure Make and Install,  Prev: Configure files,  Up: Glucas basics

Understanding the output.
*************************

In the working directory, there will be some files generated by Glucas
in addition to the 'ini' and 'queue' files (*Note Configure files::.)

Verbose output file
===================

The verbose output file is selected in the 'ini' file.  The amount of
information and the rate of output is also set there.  (*Note Configure
files::.)

   This example is the bottom of the original 'glucas.out' file in the
verification of the known Mersenne prime #39.


     Iter. 13400000 ( 99.50%), Err= 0.000, 9530.03 user 100% CPU (0.095 sec/iter).
     M13466917. Saved file at iteration 13400000. Res64: DC52C736CDD29AF0.
     M13466917. Saved file at iteration 13410000. Res64: 643D8A498F776675.
     M13466917. Saved file at iteration 13420000. Res64: 67FA818CC2047371.
     M13466917. Saved file at iteration 13430000. Res64: 29CDBF23AC751968.
     M13466917. Saved file at iteration 13440000. Res64: 8BC288C541B08E08.
     M13466917. Saved file at iteration 13450000. Res64: 6DA3BCDBBECCA0F8.
     M13466917. Saved file at iteration 13460000. Res64: 60C103D148E86603.
     M13466917 is prime!
     NEW MERSENNE PRIME DISCOVERED !!!!
     PLEASE, send email to woltman@alum.mit.edu AND
     gbv@oxixares.com
     Wed Dec  5 07:23:49 2001
     Terminated all the queued job in file: glucas.que.


   Unfortunately, it is rare to find a new prime, so it's more likely
you will get output like this:


     Iter. 4590000 ( 99.84%), Err= 0.053, 2548.27 user �99% CPU (0.258 sec/iter).
     M4597427. Saved file at iteration 4590000. Res64: 163F9694751046D6.
     M4597427 is not prime. Res64: 23AF5669C96728DE. Glucas v2.8c


Selftest output
===============

What follows is a short example from a short selftest.


     SELFTEST INFORMATION
     Host: veleta.
     OS: Linux. Release: 2.2.19. Version: #5 Mon Jun 4 10:05:30 CEST 2001
     Machine: i686
     -DY_AVAL=4 -DY_MEM_THRESHOLD=2048 -DY_BLOCKSIZE=1024 -DY_SHIFT=8
     -DY_TARGET=11 -DY_MINIMUM -DY_CACHE_LINE=4
     Selftest 31 (8192 K FFT-runlength). 100 iterations for M145000033...
     [Thu May 16 12:28:05 2002]
     Going to work with exponent 145000033
     Starting from iteration 1. Exponent 145000033. Initial shift 54852273.
     Iter.  10 ( 10.00%), Err= 0.000, 50.07 user  67% CPU (7.456 sec/iter).
     Iter.  20 ( 20.00%), Err= 0.009, 48.77 user  90% CPU (5.407 sec/iter).
     Iter.  30 ( 30.00%), Err= 0.292, 48.50 user  92% CPU (5.298 sec/iter).
     Iter.  40 ( 40.00%), Err= 0.268, 48.47 user  91% CPU (5.298 sec/iter).
     Iter.  50 ( 50.00%), Err= 0.276, 48.34 user  91% CPU (5.310 sec/iter).
     Iter.  60 ( 60.00%), Err= 0.000, 47.76 user  92% CPU (5.219 sec/iter).
     Iter.  70 ( 70.00%), Err= 0.000, 48.11 user  92% CPU (5.254 sec/iter).
     Iter.  80 ( 80.00%), Err= 0.000, 48.30 user  91% CPU (5.281 sec/iter).
     Iter.  90 ( 90.00%), Err= 0.000, 48.12 user  91% CPU (5.278 sec/iter).
     Iter. 100 (100.00%), Err= 0.000, 49.69 user  91% CPU (5.434 sec/iter).
     M145000033. Iteration 100. Res64: 2E0662F113E1871A. Glucas v2.9.0 selftest
     Selftest 31 success!
     [Thu May 16 12:37:18 2002]
     Terminated all the queued job in file: selftest.que.


   The first part displays some information about the host.  Then, it
writes the flags selected at compilation time (*Note Installing
Glucas::.)  and some information about the test, the initial random
shift, timing every ten iterations and the final result of selftest.


File: glucas.info,  Node: Configure Make and Install,  Next: Alternative builds,  Prev: Output,  Up: Installing Glucas

Configure, Make and Install Glucas.
***********************************

The 'Glucas' package includes GNU tools from 'automake' and 'autoconf'
and scripts to make the build and install tasks as easy as possible.  As
usual, the steps are

  1. configure

     The configure script checks your system to see how to compile
     'Glucas'.  You can see a list of the options available for
     configure by using
          ./configure --help

     Most of these options are generic for GNU-autoconf configure
     scripts.  Others are specific for 'Glucas'.

       a. '--enable-openmp[=n]' This option enables Glucas to use OpenMP
          threads.  The default for n is '2'.  'Glucas' will use 'n'
          threads.  You should not use this feature unless you have a
          multiprocessor system.

       b. '--enable-profiler' This option enables compiler profiler
          flags.

       c. '--enable-pthread[=n]' This option enables Glucas to use POSIX
          threads.  The default for n is '2'.  'Glucas' will use 'n'
          threads.  You should not use this feature unless you have a
          multiprocessor system.

       d. '--enable-static' This allows to build static binaries.  Enter
          this option if you want to use statically linked binary.

       e. '--enable-sunmp[=n]' This option enable Glucas to use SunMP
          threads.  The default for n is '2'.  'Glucas' will use 'n'
          threads.  You should not use this feature unless you have a
          multiprocessor system.

       f. '--enable-yaval[=n]' This option overwrites the value of
          'Y_AVAL'.  The default for n is '3'.  This will change the
          default value for your system to 'Y_AVAL=n' (*Note Glucas
          compiler options::.)

       g. '--enable-yblocksize[=n]' This option overwrites the value of
          'Y_BLOCKSIZE'.  The default for n is '512'.  This will change
          the default value for your system to 'Y_BLOCKSIZE=n' (*Note
          Glucas compiler options::.)

       h. '--enable-ycache_line[=n]' This option overwrites the value of
          'Y_CACHE_LINE'.  The default for n is '4'.  This will change
          the default value for your system to 'Y_CACHE_LINE=n' (*Note
          Glucas compiler options::.)

       i. '--enable-ykill_branches' This option enables
          'Y_KILL_BRANCHES'.  By default this is disabled.  Some targets
          have this option enabled.(*Note Glucas compiler options::.).

       j. '--enable-ylong_macros' This option enables 'Y_LONG_MACROS'.
          By default this is disabled.  Some targets have this option
          enabled.(*Note Glucas compiler options::.)

       k. '--enable-ypadding_level[=n]' This option sets the level of
          padding of main array data.  Overwrites the value of
          'Y_PADDING_LEVEL' The allowed values for 'n' are from 0 up to
          4.  Padding level 0 will not actually perform any padding.
          Padding level 4 will insert four different pad sizes to avoid
          as possible cache thrashing.  (*Note Glucas compiler
          options::.)

       l. '--enable-ymany_registers' This option enables
          'Y_MANY_REGISTERS'.  By default this is disabled.  (*Note
          Glucas compiler options::.)

       m. '--enable-ymaximum' This option enables 'Y_MAXIMUM'.  By
          default this is disabled.  (*Note Glucas compiler options::.)

       n. '--enable-ymem_threshold[=n]' This option overwrites the value
          of 'Y_MEM_THRESHOLD'.  The default for n is '2048'.  This will
          change the default value for your system to
          'Y_MEM_THRESHOLD=n' (*Note Glucas compiler options::.)

       o. '--enable-yminimum' This option enables 'Y_MINIMUM'.  By
          default this is disabled.  Some targets have this option
          enabled.(*Note Glucas compiler options::.)

       p. '--enable-ysecure' This option enables 'Y_SECURE'.  By default
          this is disabled.  Some targets have this option
          enabled.(*Note Glucas compiler options::.)

       q. '--enable-yshift[=n]' This option overwrites the value of
          'Y_SHIFT'.  The default for n is '8'.  This will change the
          default value for your system to 'Y_SHIFT=n' (*Note Glucas
          compiler options::.)

       r. '--enable-ysse2' This option enables the use of SSE2
          extensions for Intel Pentium4(r) and AMD64 (r) processors.
          This option will build binaries that only can be executed on
          this targets, otherwise we will get an *Illegal instruction*
          error message.

       s. '--enable-yvectorize' This option enables 'Y_VECTORIZE'.  By
          default this is disabled.  Some targets have this option
          enabled.(*Note Glucas compiler options::.).

       t. '--enable-yvectorize2' This option enables 'Y_VECTORIZE2'.  By
          default this is disabled.  Some targets have this option
          enabled.(*Note Glucas compiler options::.)

       u. '--enable-ytarget[=n]' This option overwrites the value of
          'Y_TARGET'.  The default for n is '0'.  This will change the
          default value for your system by 'Y_TARGET=n' (*Note Glucas
          compiler options::.)

     Among the generic configure options one very important is the
     compiler being used.  You can select your favorite compiler for
     your platform with
          CC=your_compiler.

     As example, if you want to use Intel (C) C++ compiler instead of
     GNU-gcc in your x86 machine

          ./configure CC=icc

     You also can include some macro definitions directly defining
     'GLUCAS_FLAGS' when configuring.  As example, if you want to
     include preload code made for Itaniums, you could try

          ./configure GLUCAS_FLAGS=-DY_ITANIUM

  2. make

     Once the configure step has checked your system successfully, it
     generates the 'Makefile'

     Then you only need to invoke the 'make' utility to generate a
     binary

          make

     It will create the binary.  Usually named 'Glucas' on Unix systems.

  3. install

     To install the binary you should invoke again 'make' utility

          make install

     this will install the binary in your local binary directory.  See
     'INSTALL' file in the source directory to know more about install
     options.


File: glucas.info,  Node: Alternative builds,  Next: Glucas compiler options,  Prev: Configure Make and Install,  Up: Installing Glucas

How to make your own binary.
****************************

This section is for users who want to build 'Glucas' using other than
the default settings in the 'configure' script or try tuning 'Glucas'
for their specific hardware.

   You will need to know about your compiler settings, especially the
optimization flags.  You will also need to know about 'Glucas' and
'YEAFFT' configuration flags and 'ini' files.

   'Makefile.Glucas' is a skeleton of the 'Makefile'.  You have to edit
the proper flags and macro definitions in that file.  This file is
commented and also has examples for several architectures.  Here is an
excerpt of the top of this file.  You have to edit it and fill CC, O,
LINK, C, OUT, CFLAGS, CFLAGS1, CFLAGS0, and DEFINE_GLUCAS. (*Note Glucas
compiler options::.)


     # HOW TO CALL THE COMPILER. SELECT HERE YOUR COMPILER
     CC=
     # YOU CAN CHANGE HERE THE SUFFIXES FOR OBJECT
     O=
     # HOW TO LINK
     LINK=
     #ONLY COMPILE FLAG
     C=
     #OUTPUT FLAG
     OUT=

     # EXAMPLE for GNU/GCC compiler
     #CC=gcc
     #O=o
     #LINK=$(CC)
     #C=-c
     #OUT=-o

     #
     # SET THE OPTIMAL COMPILER FLAGS AND GLUCAS DEFINE HERE
     #
     CFLAGS=

     #
     # SOME COMPILERS DON'T WORK WELL WITH CFLAGS, SO WE NEED A LESSER
     # OPTIMIZATION FLAGS
     #
     CFLAGS1=

     #
     # tricky.c file needs even lesser optimization flag
     #
     CFLAGS0=

     #
     # SET THE OPTIMAL MACROS FOR GLUCAS
     #
     DEFINE_GLUCAS=


   Only DEFINE_GLUCAS is specific for 'Glucas', the other flags depend
on the users compiler/architecture.


File: glucas.info,  Node: Glucas compiler options,  Prev: Alternative builds,  Up: Installing Glucas

Passing Glucas options to the compiler.
***************************************

To make 'Glucas' as fast and reliable as possible, we have to include
some flags and macro definitions at compile time.  Some flags are
specific for the compiler and others for 'Glucas' or the 'YEAFFT'
library.

   We cannot help about the specific compiler flags.  You should read
the compiler's documentation.  Select those flags which make the binary
as fast as possible.

   There are some macro definitions we can set using the macro
definition facility of most compilers.  Then you have to include

     -DYOUR_OPTION1[=value1] [-DYOUR_OPTION2[=value2]] ...

   with the compiler flags when invoking the compiler.

   For Metrowerks CodeWarrior a similar functionality can be achieved by
editing the parameters in the file 'macos-codewarrior-prefix.h' and
including it in the Prefix File setting of the C/C++ Compiler Settings.

YEAFFT options
==============

Y_AVAL=VALUE
     It gives the type and size of radices that will be used in FFTs.
     (*Note Glucas internals::.)  The default value is '3'.  We can
     define '4' or '5'.  It is recommended to use the default and then
     you can see the performance with other choices.

          Y_AVAL=3 YEAFFT uses radices 4,5,6,7,8 and 9 in FFTs passes.
          It is the default and the best option on most systems.
          Y_AVAL=4 It uses radices 4,5,6,7,8 and 9 in first FFTs pass and
          8,16 in the other passes.
          Y_AVAL=5 It also can use radix32 reduction in middle passes.
          There are few processors which we can gain some speed.


Y_BLOCKSIZE=VALUE
     This parameter sets the size of contiguous elements in the main
     array data without padding (in size of doubles).  This padding is
     necessary to avoid cache thrashing.  Without it, the performance
     drops drastically.  It is related with 'Y_SHIFT' and
     'Y_PADDING_LEVEL'.


Y_SHIFT=VALUE
     This parameter and 'Y_BLOCKSIZE' set the basic size of the array
     pad.  It is computed as
          basic_pad_size = (Y_BLOCKSIZE) >> Y_SHIFT
     Note, that the basic pad size must be greater than one to avoid
     alignement problems.


Y_PADDING_LEVEL=VALUE
     This parameter sets the complexity in the padding.  If
     'Y_PADDING_LEVEL=0' then actually there is no padding.  If
     'Y_PADDING_LEVEL=n' holes have sizes from 1 to n, depending on the
     result of padding algorithm.  If level is 1 then all holes have the
     same size.


Y_MANY_REGISTERS
     Defining it, in addition to 'Y_AVAL > 3', you can use a first radix
     pass reduction from 10 to 16 (*Note Glucas internals::.)  Due to
     the many local variables these routines use, it is only an
     advantage when the processor has a lot of registers (32 FPU
     registers or more).  Indeed, we still have not seen a machine which
     uses this feature with gain.


Y_MEM_THRESHOLD=VALUE
     To avoid when possible cache misses, the FFT passes are different
     depending on the pad between data (*Note Glucas internals::.)  The
     threshold from pass 1 to 2 is defined by this parameter.  The
     default is set to 2048.  It is a good choice for most systems, but
     others like Alpha ev67 will run faster by using 8192 instead.  The
     'value' should be a power of two.


Y_TARGET=VALUE
     The 'YEAFFT' library intensively uses preprocessor C macros.  Most
     of the FFT tasks are made by using bits of macros defined in the
     file 'ygeneric.h'.  This file is written with a generic processor
     in mind.  This generic processor is the default and is set defining
     'Y_TARGET=0'.  Sure, there are many things one could write better
     for a specific processor.  If you are brave enough, do it.  You can
     even write a collection of assembler macros.  This is an advanced
     feature, we recommend do not touch it.  You should change some
     lines in 'mccomp.h' file and write your own 'my_proc.h' file.


     Recently, from release v.2.8a.  Prefetch hints has been introduced.
     It increases the performance a lot in some cases.  To use this
     feature, you have to define other than generic Y_TARGET. Up to
     release 2.8b this is the list of 'value' for targets.  Options
     16,17,41 and 51 are not recommended, they are still experimental.

     '0'
          'Generic'.  No prefetch other than builtin GCC v3.1 used.  All
          pure C code.  Generic C compiler.
     '1'
          'Pentium, Pentium MMX, Pentium II'.  No prefetch.  A lot of
          assembler lines.  GNU/gcc compiler or compatible '_asm_'
          extensions.
     '11'
          'Pentium 3'.  Prefetch used.  A lot of assembler code.
          GNU/gcc compiler or compatible '_asm_' extensions.
     '12'
          'AMD Athlon'.  Prefetch used.  A lot of assembler code.
          GNU/gcc compiler or compatible '_asm_' extensions.
     '16'
          'Pentium 3'.  Prefetch used.  Only two lines of assembler
          code.  GNU/gcc compiler or compatible '_asm_' extensions.  Not
          recommended.
     '17'
          'AMD Athlon'.  Prefetch used.  Only two lines of assembler
          code.  GNU/gcc compiler or compatible '_asm_' extensions.  Not
          recommended.
     '21'
          'PowerPC 601'.  Prefetch used.  Only two lines of assembler
          code.  GNU/gcc compiler or compatible '_asm_' extensions or
          Metrowerks Codewarrior intrinsics.
     '23'
          'PowerPC 604e, 7xx, 74xx'.  Prefetch used.  Only two lines of
          assembler code.  GNU/gcc compiler or compatible '_asm_'
          extensions or Metrowerks Codewarrior intrinsics.
     '31'
          'Alpha ev56, ev6, ev67, ev68'.  Prefetch used.  Only two lines
          of assembler code.  Compaq-C compiler with 'asm' calls.
     '32'
          'Alpha ev56, ev6, ev67'.  Prefetch used.  Only two lines of
          assembler code.  GNU/gcc compiler or compatible '_asm_'
          extensions.
     '41'
          'Ultrasparc-II'.  No prefetch.  Only two lines of assembler
          code.  GNU/gcc compiler or compatible '_asm_' extensions.  Not
          recommended.
     '51'
          'Intel Itanium IA-64'.  No prefetch.  Only two lines of
          assembler code.  GNU/gcc compiler or compatible '_asm_'
          extensions.  Not recommended, use 'Y_ITANIUM' option for a
          terrific performance.

Y_PREFETCH_EXPENSIVE
     When prefetch is available using 'Y_TARGET' other than generic,
     some routines can be unrolled to avoid unnecessary calls to
     prefetch hints.  It could be useful when prefetch hints are
     expensive in performance terms.  At the moment, it is still an
     experimental feature.


Y_LONG_MACROS
     'YEAFFT' code is coded based mostly on small macros doing elemental
     FFT work.  Sometimes it is more convenient to use big macros to
     adjust and tune some long latencies operations in a more convenient
     way.


Y_VECTORIZE2
     Don't take this option as a multithreaded one.  For radix-4
     reduction it is possible to unroll inner loops with a register
     pressure similar to radix-8.  It can help a bit for some
     processors.


Y_ITANIUM
     This option activates special code for IA64 processors since 2.8c.
     It has no effect in earlier releases.  This code is plain C code,
     no assembler lines, but gives a big penalty in performance for
     other than Intel IA64 processors.  It is strongly recommended to
     use this option for IA64 machines, you can double the performance.


Y_MINIMUM
     This option configures 'YEAFFT' to use the minimum possible amount
     of precomputed trigonometric factors.  This increase the work at
     FFT-time but reduces the memory traffic.  On some systems it is
     worthwhile.  The default is to precompute only a part of
     trigonometric factors and complete at FFT-time.


Y_MAXIMUM
     This option is the opposite to Y_MINIMUM. Here, all the
     trigonometric factors are precomputed, and so there are less work
     to do at FFT-time.  The negative part is that this increases the
     memory traffic and can slowdown the speed.


_PTHREADS=VALUE
     This option enables the use of POSIX threads.  This option is
     automatically filled building the binary with 'configure' script
     and using '--enable-pthread=n'.  If you want to use N threads you
     should then add '-D_PTHREADS=n' to your command line compiler
     options.  When using 'configure' the option '--enable-pthread' is
     equivalent to '--enable-pthread=2'.  This option is not recommended
     for single processor machines.


_OPENMP
     This option enables the use of OpenMP (http://www.openmp.org)
     directives.  If you want to set the number of threads to use you
     have to include the option 'Y_NUM_THREADS'.  *Warning*.  If you
     want to use OpenMP multiprocessing you have to enable it with the
     proper compiler flag (usually '-omp').  Then, the compiler have
     already defined '_OPENMP' macro so *YOU DON'T HAVE TO DEFINE IT
     EXPLICITLY*. This option is not recommended for single processor
     machines.


_SUNMP
     This option enables Sun MP C directives see docs about SunWSpro C
     compiler (http://docs.sun.com/).  *Warning*: You have to define
     'PARALLEL=n' in your shell environment, and you also have to define
     'Y_NUM_THREADS' and the specific compiler flag '-xexplicitpar'.
     This option is not recommended for single processor machines.


Y_NUM_THREADS=VALUE
     This option is used to set EXPLICITLY how many threads are used in
     'OpenMP' or 'SunMP' multithreaded options.  You have to assign a
     value when using 'SunMP' but not when using 'OpenMP' (here the best
     choice can be computed at runtime).  Anyway, to avoid other than
     power of two number of threads, it is better to use this option
     whenever you use both '_OPENMP' or '_SUNMP'.

GLUCAS options
==============

The following macros are defined to manage some aspects of Lucas Lehmer
tests, not the FFT routines.
Y_SECURE
     When defined, 'Glucas' makes a round off check every iteration
     (*Note Glucas internals::.)  It costs about 5% of performance, but
     in some cases it is convenient.  We recommend to use it in systems
     with unreliable hardware/software (low end PC's, overclocked
     systems, etc ...).  In 2.9.2, when it is not defined the round off
     error is checked in the first 131072 iterations after start.  If
     any error of these iterations is over 0.40 then 'Glucas' restarts
     trying to adjust its accuracy.  Once the initial phase is passed,
     'Glucas' still continues checking the roundoff error but now every
     64 iterations and with a higher threshold (0.45).  A further error
     will reinit the test, with accuracy increased, from the last save
     file.

     You can also manage the roundoff check at run time by editing the
     ini file (*Note Configure files::.)


Y_KILL_BRANCHES
     The carry and normalization phase of 'Discrete Weighted Transform'
     (*Note Glucas internals::.)  has some unpredictable branches.  This
     can slowdown the performance in some processors.  'Glucas' has an
     alternative code to avoid all these branches but with some float
     and integer instructions as cost.  Some processors can gain with
     this option activated.


Y_VECTORIZE
     If this option is used, it is possible to avoid some dependency
     stalls in carry and normalization phase of 'Discrete Weighted
     Transform'.


File: glucas.info,  Node: GPL license,  Prev: Concept Index,  Up: Top

Appendix A GNU GENERAL PUBLIC LICENSE
*************************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom to
share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users.  This General Public
License applies to most of the Free Software Foundation's software and
to any other program whose authors commit to using it.  (Some other Free
Software Foundation software is covered by the GNU Library General
Public License instead.)  You can apply it to your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it if
you want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on the
     Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's source
     code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion of
     it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program or
          any part thereof, to be licensed as a whole at no charge to
          all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not apply
     to those sections when you distribute them as separate works.  But
     when you distribute the same sections as part of a whole which is a
     work based on the Program, the distribution of the whole must be on
     the terms of this License, whose permissions for other licensees
     extend to the entire whole, and thus to each and every part
     regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on a
     volume of a storage or distribution medium does not bring the other
     work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either source
     or binary form) with the major components (compiler, kernel, and so
     on) of the operating system on which the executable runs, unless
     that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this License
     to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program subject
     to these terms and conditions.  You may not impose any further
     restrictions on the recipients' exercise of the rights granted
     herein.  You are not responsible for enforcing compliance by third
     parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who receive
     copies directly or indirectly through you, then the only way you
     could satisfy both it and this License would be to refrain entirely
     from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies to
     it and "any later version", you have the option of following the
     terms and conditions either of that version or of any later version
     published by the Free Software Foundation.  If the Program does not
     specify a version number of this License, you may choose any
     version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted by
     the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                              NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
     AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
     OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
     PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
     DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
     OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YYYY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than 'show w' and 'show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: glucas.info,  Node: Save file format,  Next: Concept Index,  Prev: Contributors,  Up: Top

Appendix B INTERCHANGEABLE FORMAT FOR MERSENNE NUMBERS RESIDUES
***************************************************************

                               Version 2

Introduction
============

Every day, the length of numbers being analyzed in *GIMPS* contest grows
and grows, and so, the time needed to perform a Lucas-Lehmer test.  An
user can be tired of search, buy a new machine or change the client.  In
all cases, it would be nice having an interchangeable format to avoid
loosing many CPU hours.

   *Glucas* program can use this format and so, the save files can be
used by all platforms ( 32/64 bits, BIG-ENDIAN / LITTLE-ENDIAN) with two
complement integer arithmetic.  Reading and writing this kind of files
is a bit slower than other formats (it cost about half a L-L iteration)
but how often do we read/write a save file ?.

   What follows is a brief description of the format.

System compatibility requirements
=================================

The minimum requirements needed to read or write a save file with the
proposed format are:
   - Two-complement integer arithmetic.
   - Unsigned integer types of 32 or 64 bits length.
   - Unsigned 8-bits char or byte type.

The format.
===========

The save file is divided into blocks of 8-bytes length.  Every block
must be considered as a 64-bits unsigned integer type.

         FORMAT OF A 8-BYTES BLOCK:
         byte 0:  bits 7-0 . First position in file (least significant byte)
         byte 1:  bits 8-15
         byte 2:  bits 16-23
         byte 3:  bits 24-31
         byte 4:  bits 32-39
         byte 5:  bits 40-47
         byte 6:  bits 48-55
         byte 7:  bits 56-63  last position in file (most significant byte)


   The blocks are:

BLOCK 0: BYTES 1-8 .FORMAT VERSION
     This is reserved to identify the file as a *Interchangeable
     Mersenne Residue File Format*.
          BLOCK 0 FORMAT:
          bytes 0-4: The signature 0x006A64B1. This is the hexadecimal
                     representation of 6972593 (the last known Mersenne
                     prime exponent when development of this format
                     begun).
          bytes 4-7: the version. This is version 2. So 0x00000002


BLOCK 1: BYTES 9-16 .PROGRAM IDENTIFICATION
     This is reserved to identify the program and version which generate
     the file.  As an orientation, the proposal is:

          BLOCK 1 FORMAT:
          byte 0: the program:
               Example. Byte 2 of block 0 can be, in hexadecimal
                        0x11 for prime95/mprime
                        0x22 for Mlucas
                        0x33 for Glucas
                                .......
          bytes 1-3: the version. Every program should use these three bytes
                     in its own format.
          byte 4: What the residue is:
                  0 : Lucas-Lehmer test residue.
                  1 : p-1 residue.
                  2 : A general mersenne residue,
                  (example : a residue in a ECM factorization).
          bytes 5-7: at the moment set two 0. Reserved for future use.


BLOCK 2: BYTES 17-24. EXPONENT.
     This block is changed from version 1.  In version 1 the exponent
     occupied the complete block.  Now the upper half has other
     information.

          BLOCK 2 FORMAT:
          Bytes 0-3: The exponent of the Mersenne number, e.g, 657849 for
                     M657849. Unsigned integer format.

          Bytes 4-7: The optional shift account. To get the proper residue,
                     it has to be rotated to the right this number of bits.
                     In a non rotated version it is set to 0.


BLOCK 3: BYTES 25-32. THE FFT RUNLENGTH USED IF ANY.
     An integer indicating the FFT run-length, in size_of_reals, used to
     compute the residue saved.  Actually, it is only an informative
     data, every binary can continue the work with a FFT-runlength
     according to their own accuracy capabilities.

BLOCK 4: BYTES 33-40. ITERATION / B1 LIMIT.
     In a L-L test: The iteration of the Lucas-Lehmer test saved.  This
     is important to unify:

                  4 would be the iteration 0
                  14 would be the iteration 1
                  .....


     If the starting point L(0) is not 4, like prime95 does, the residue
     should be rotated according with the number of bits read in block
     2.  Once rotated L(0)=4, L(1)=14 and so on.

     In a P-1 factorization it must be the B1 limit.

     For other uses it is undefined.

BLOCK 5: BYTES 41-48. ROUND OFF ERROR
     In a L-L test: the round off error of the iteration being saved.
     Because we need to store it in integer format, the error is
     transformed according to:


          error_saved = (unsigned int)(fabs(frac_roundoff_err) * 1000000.0)

     For other kinds of residues it is yet undefined.  (may be a B2
     limit)


BLOCKS 6 TO 5+N: BYTES 49 TO N*8+48: THE RESIDUE
     This part contains the residue.  It is stored in compact
     two-complement integer form, using all the blocks needed to store
     the 'q' bits of the Mersenne Number 'Mq'.  The needed N blocks can
     be easily computed by

          N := floor ( (q-1)/64 + 1)

     The unused bits (if any) in the last block must be filled by
     zeroes.  The first block of the residue (first on file) will
     contain bits 0-63, the second 64-127 and so on.


BLOCK 6+N: BYTES N*8+49 TO N*8+56: THE LAST CARRY.
     In the normalization process from the float array in DWT to the
     compact integer form, one must play with a carry propagation.
     After the last float DWT array element has been transformed, it
     remains a 'last carry' one needs to add to the residue (usually
     only to the first bits).  If the write routines already have
     written the first residue blocks (to save memory) this blocks
     should need to be read again.  To avoid this problem, this block
     contains the last carry.

     *NOTE*: The last carry, if non-zero, usually is -1, so all the bits
     are zeroes or ones.  *Glucas* adds the last carry to the residue
     before writing, so this block always is zero.


BLOCK 7+N: BYTES N*8+57 TO N*8+64: THE SUM CHECK CONTROL.
     This block contains the sum of the previous blocks mod(2^32 - 1).
     It is easy and fast to compute with both 32 and 64 bits scheme.


BLOCKS 8+N TO THE END OF FILE: UNDEFINED YET
     More blocks can be added at the end of the file.  This part of file
     can be used for purposes like a brief history of the machines/users
     and errors from the beginning of work to the actual state.


File: glucas.info,  Node: Concept Index,  Next: GPL license,  Prev: Save file format,  Up: Top

Appendix C Concept and keyword Index
************************************

 [index ]
* Menu:

* -c Command line option:                Usage.               (line  21)
* -d Command line option:                Usage.               (line  25)
* -D Command line option:                Usage.               (line 126)
* -f Command line option:                Usage.               (line  88)
* -h Command line option:                Usage.               (line  34)
* -i Command line option:                Usage.               (line 109)
* -K Command line option:                Usage.               (line  38)
* -n Command line option:                Usage.               (line  56)
* -N Command line option:                Usage.               (line  63)
* -o Command line option:                Usage.               (line  46)
* -q Command line option:                Usage.               (line 114)
* -r Command line option:                Usage.               (line  95)
* -s Command line option:                Usage.               (line  99)
* -S Command line option:                Usage.               (line 104)
* -T Command line option:                Usage.               (line  71)
* -v Command line option:                Usage.               (line  84)
* -W Command line option:                Usage.               (line 131)
* -z Command line option:                Usage.               (line  78)
* _OPENMP:                               Glucas compiler options.
                                                              (line 204)
* _PTHREADS:                             Glucas compiler options.
                                                              (line 194)
* _SUNMP:                                Glucas compiler options.
                                                              (line 215)
* acknowledgments:                       Contributors.        (line  15)
* Alpha e6:                              Glucas compiler options.
                                                              (line 133)
* Alpha e67:                             Glucas compiler options.
                                                              (line 133)
* Alpha e68:                             Glucas compiler options.
                                                              (line 133)
* Alpha ev56:                            Glucas compiler options.
                                                              (line 133)
* Alternative output flag:               Configure files.     (line  14)
* AMD Athlon:                            Glucas compiler options.
                                                              (line 114)
* AMD Athlon <1>:                        Glucas compiler options.
                                                              (line 121)
* assembler code:                        Glucas compiler options.
                                                              (line 103)
* authors:                               Contributors.        (line   6)
* autoconf:                              Configure Make and Install.
                                                              (line   6)
* automake:                              Configure Make and Install.
                                                              (line   6)
* CFLAGS:                                Alternative builds.  (line  14)
* CFLAGS0:                               Alternative builds.  (line  14)
* CFLAGS1:                               Alternative builds.  (line  14)
* check iteration flag:                  Configure files.     (line  21)
* Conditions for copying Glucas-YEAFFT:  Copying.             (line   6)
* configure:                             Installing Glucas.   (line  56)
* Configure files:                       Usage.               (line   6)
* configure script:                      Configure Make and Install.
                                                              (line  10)
* configure script options:              Configure Make and Install.
                                                              (line  20)
* Copying conditions:                    Copying.             (line   6)
* Decimation in frequency:               Glucas internals.    (line  70)
* DEFINE_GLUCAS:                         Alternative builds.  (line  62)
* DIF:                                   Glucas internals.    (line  70)
* discrete weighted factors:             Glucas internals.    (line  65)
* Discrete Weighted Transform:           Glucas internals.    (line 146)
* Discrete Weighted Transform <1>:       Mersenne number.     (line  25)
* double-check:                          Lucas-Lehmer test.   (line  26)
* double-check <1>:                      Usage.               (line  25)
* download Glucas:                       Installing Glucas.   (line   6)
* DWT:                                   Mersenne number.     (line  25)
* DWT factors:                           Glucas internals.    (line 107)
* dyadic square:                         Glucas internals.    (line  89)
* Fast Fourier Transform:                Glucas and YEAFFT.   (line   6)
* Fast Fourier Transform <1>:            Introduction to YEAFFT.
                                                              (line   6)
* Fast Fourier Transform <2>:            Mersenne number.     (line  25)
* fast Galois Transform:                 Glucas internals.    (line 150)
* FFT:                                   Glucas and YEAFFT.   (line   6)
* FFT <1>:                               Introduction to YEAFFT.
                                                              (line   6)
* FFT <2>:                               Mersenne number.     (line  25)
* FFT pass 1:                            Glucas internals.    (line  80)
* FFT pass 2:                            Glucas internals.    (line  86)
* FFT runlength:                         Selftest.            (line  26)
* Force bigger FFT runlength.:           Usage.               (line  78)
* generic target:                        Glucas compiler options.
                                                              (line 103)
* GIMPS:                                 Introduction to Glucas.
                                                              (line  14)
* GIMPS <1>:                             Glucas internals.    (line 134)
* Glucas:                                Glucas and YEAFFT.   (line  13)
* Glucas <1>:                            Introduction to Glucas.
                                                              (line   6)
* Glucas structure:                      Glucas internals.    (line  19)
* glucas.que:                            Usage.               (line 114)
* Glucas_test:                           Glucas_test.         (line   6)
* GNU/gcc:                               Introduction to YEAFFT.
                                                              (line   6)
* ini file examples:                     Configure files.     (line 113)
* ini files:                             Usage.               (line   6)
* inifile option:                        Usage.               (line 109)
* initial random shift:                  Usage.               (line  25)
* initial shift:                         Lucas-Lehmer test.   (line  26)
* initial shift <1>:                     Usage.               (line 126)
* input file:                            Usage.               (line 137)
* Intel Itanium IA-64:                   Glucas compiler options.
                                                              (line 144)
* inverse DWT factors:                   Glucas internals.    (line 107)
* iteration output:                      Configure files.     (line  36)
* Known Mersenne primes:                 Mersenne number.     (line  38)
* last error flag:                       Configure files.     (line  42)
* License conditions:                    Copying.             (line   6)
* Lucas-Lehmer test:                     Introduction to Glucas.
                                                              (line   6)
* Lucas-Lehmer test <1>:                 Glucas basics.       (line   6)
* Lucas-Lehmer test <2>:                 Mersenne number.     (line  18)
* Lucas-Lehmer test.:                    Lucas-Lehmer test.   (line   6)
* machine Id:                            Configure files.     (line  94)
* make:                                  Installing Glucas.   (line  56)
* make <1>:                              Configure Make and Install.
                                                              (line 132)
* make install:                          Configure Make and Install.
                                                              (line 144)
* makefile:                              Configure Make and Install.
                                                              (line 132)
* Makefile.Glucas:                       Alternative builds.  (line  14)
* mathematical concepts:                 Glucas internals.    (line 137)
* Memory requirements:                   Selftest.            (line  70)
* Mersenne exponent.:                    Mersenne number.     (line  10)
* Mersenne interchangeable residue format: Glucas internals.  (line  59)
* Mersenne number:                       Introduction to Glucas.
                                                              (line   6)
* Mersenne number <1>:                   Glucas basics.       (line   6)
* Mersenne number <2>:                   Mersenne number.     (line   6)
* Mersenne primes:                       Mersenne number.     (line  34)
* modular reduction:                     Mersenne number.     (line  22)
* Nice adjustment option:                Usage.               (line  63)
* no nice flag:                          Usage.               (line  56)
* only check flag:                       Configure files.     (line  47)
* OPENMP:                                Glucas compiler options.
                                                              (line 204)
* output file:                           Configure files.     (line  26)
* Pentium:                               Glucas compiler options.
                                                              (line 107)
* Pentium 3:                             Glucas compiler options.
                                                              (line 111)
* Pentium 3 <1>:                         Glucas compiler options.
                                                              (line 117)
* Pentium II:                            Glucas compiler options.
                                                              (line 107)
* Pentium MMX:                           Glucas compiler options.
                                                              (line 107)
* posix threads:                         Glucas internals.    (line  41)
* PowerPC 601:                           Glucas compiler options.
                                                              (line 125)
* PowerPc 604e:                          Glucas compiler options.
                                                              (line 129)
* PowerPC 74XX:                          Glucas compiler options.
                                                              (line 129)
* PowerPC 7xx:                           Glucas compiler options.
                                                              (line 129)
* prebuilt binary:                       Installing Glucas.   (line  14)
* prefetch:                              Glucas compiler options.
                                                              (line  97)
* prefetch <1>:                          Glucas compiler options.
                                                              (line 103)
* prefetch data:                         Glucas internals.    (line  49)
* prime:                                 Mersenne number.     (line  34)
* prime glossary:                        Glucas internals.    (line 142)
* prime95:                               Introduction to Glucas.
                                                              (line  18)
* PrimeNet:                              Introduction to Glucas.
                                                              (line  18)
* PTHREADS:                              Glucas compiler options.
                                                              (line 194)
* QA interim file:                       Configure files.     (line  54)
* queue file:                            Usage.               (line 154)
* queue file option:                     Usage.               (line 114)
* reserving exponents:                   Introduction to Glucas.
                                                              (line  18)
* Result file option.:                   Usage.               (line  95)
* results file:                          Usage.               (line   6)
* round trick:                           Glucas internals.    (line  46)
* roundoff check error:                  Configure files.     (line  68)
* save file:                             Glucas internals.    (line 113)
* save file <1>:                         Configure files.     (line  80)
* save files:                            Glucas_test.         (line   6)
* Select number of threads:              Usage.               (line  71)
* selftest:                              Selftest.            (line   6)
* selftest all:                          Selftest.            (line  59)
* selftest big:                          Selftest.            (line  46)
* selftest enormous:                     Selftest.            (line  54)
* selftest huge:                         Selftest.            (line  50)
* selftest option:                       Usage.               (line  99)
* selftest option (large):               Usage.               (line 104)
* selftest primenet:                     Selftest.            (line  33)
* selftest primenet <1>:                 Selftest.            (line  42)
* selftest small:                        Selftest.            (line  39)
* selftest.out:                          Selftest.            (line  84)
* selftest.res:                          Selftest.            (line  84)
* time output flag:                      Configure files.     (line  89)
* Timing Glucas:                         Selftest.            (line  77)
* Ultrasparc-II:                         Glucas compiler options.
                                                              (line 140)
* unzipping file:                        Installing Glucas.   (line  21)
* usage:                                 Usage.               (line  13)
* verbose output file:                   Output.              (line  12)
* version flag:                          Usage.               (line  84)
* work directory:                        Usage.               (line 131)
* worktodo.ini:                          Usage.               (line 114)
* YEAFFT:                                Glucas and YEAFFT.   (line   6)
* YEAFFT <1>:                            Introduction to YEAFFT.
                                                              (line   6)
* Y_AVAL:                                Glucas compiler options.
                                                              (line  29)
* Y_BLOCKSIZE:                           Glucas compiler options.
                                                              (line  43)
* Y_ITANIUM:                             Glucas compiler options.
                                                              (line 171)
* Y_KILL_BRANCHES:                       Glucas compiler options.
                                                              (line 254)
* Y_LONG_MACROS:                         Glucas compiler options.
                                                              (line 157)
* Y_MANY_REGISTERS:                      Glucas compiler options.
                                                              (line  67)
* Y_MAXIMUM:                             Glucas compiler options.
                                                              (line 187)
* Y_MEM_THRESHOLD:                       Glucas compiler options.
                                                              (line  76)
* Y_MINIMUM:                             Glucas compiler options.
                                                              (line 179)
* Y_NUM_THREADS:                         Glucas compiler options.
                                                              (line 223)
* Y_PADDING_LEVEL:                       Glucas compiler options.
                                                              (line  59)
* Y_PREFETCH_EXPENSIVE:                  Glucas compiler options.
                                                              (line 149)
* Y_SECURE:                              Glucas compiler options.
                                                              (line 236)
* Y_SHIFT:                               Glucas compiler options.
                                                              (line  51)
* Y_TARGET:                              Glucas compiler options.
                                                              (line  85)
* Y_VECTORIZE:                           Glucas compiler options.
                                                              (line 263)
* Y_VECTORIZE2:                          Glucas compiler options.
                                                              (line 164)



Tag Table:
Node: Top223
Node: Copying1618
Node: Glucas and YEAFFT2484
Node: Introduction to YEAFFT3575
Node: Introduction to Glucas4485
Node: Installing Glucas6465
Node: Glucas basics9045
Node: Invoking Glucas10134
Node: Glucas internals10553
Node: Contributors17719
Node: Mersenne number19484
Node: Lucas-Lehmer test21381
Node: Selftest22740
Node: Glucas_test26621
Node: Usage27518
Node: Configure files34642
Node: Output40660
Node: Configure Make and Install44247
Node: Alternative builds50678
Node: Glucas compiler options52411
Node: GPL license64005
Node: Save file format83189
Node: Concept Index89874

End Tag Table
